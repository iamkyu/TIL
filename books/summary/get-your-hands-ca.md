# Get Your Hands Dirty on Clean Architecture

> 톰홈버그스 저 | Packt | 2019.


![book-cover](https://user-images.githubusercontent.com/13076271/101275124-9f53b100-37e6-11eb-9ac3-46fb8b4d493b.png)

[책 구매하기](https://www.amazon.com/Hands-Dirty-Clean-Architecture-hands-ebook/dp/B07YFS3DNF/ref=sr_1_1?dchild=1&keywords=Get+Your+Hands+Dirty+on+Clean+Architecture&qid=1607242420&sr=8-1)



***<u>본 내용은 책 내용에 대한 개인적 이해를 바탕으로 한 요약과 생각이므로 정확한 내용은 반드시 책을 참고하길 권장함.</u>***

# Chapter1. 계층 아키텍처의 문제

- 대부분 경험해봤을, 경험하고 있을 웹 - 도메인 - 영속 계층 으로 이뤄진 전통적인 계층 아키텍처 (웹)
- 계층화는 굉장히 견고한 아키텍처 패턴. 이를 잘 지킨다면 도메인 로직을 웹, 영속화 계층으로부터  독립적인 계층으로 유지 가능함.
- 그러나 저자의 경험으로 계층 아키텍처는 개방된 측면을 너무 많이 가지고 있어 시간이 지남에 따라 점점 아키텍처가 오염되고 소프트웨어를 바꾸기 어렵게 만듬.

## 데이터베이스 중심 설계 (It Promotes Database-Driven Design)

- 전통적인 계층 구조의 기반에서 모든 레이어는 영속 계층 위에 쌓임.
- 이런 의존성의 흐름에 따라 우리는 핵심 비즈니스 로직 보다 데이터베이스에 어떤 값이 저장할지 먼저 고민함. 즉 상태에 관한 고민.
- '상태'도 물론 애플리케이션의 중요한 부분이지만 도메인의 핵심은 '행동'.
- 따라서 우리는 다른 어떤 것보다 도메인 로직 설계가 선행되어야 함.
- 또한 ORM 프레임워크와 계층 아키텍처가 함께 사용될 때, 비즈니스 규칙은 영속화와 관련 내용이 드러나기 쉬움. 레이지로딩, 트랜잭션, 캐시 플러시(flush) 등.

## 침범하기 쉬움 (Its' Prone to Shortcuts)

- 계층 아키텍처의 규칙은 오직 하나뿐임, 명확히 구분 된 계층. 각 컴포넌트는 자신의 계층 또는 하위 계층만 접근 가능함.
- 만약, 하위 계층에서 상위 계층의 특정 컴포넌트에 접근해야 할 때 해당 컴포넌트를 하위 계층으로 이동 시켜 문제를 해결할 수 있음.
- 책의 예제는 Helper, Util 이라는 이름을 가진 어떤 계층에 두기 애매한 컴포넌트들이 모두 영속성 계층에 포함되고 이런 컴포넌트에 도메인 계층에서, 영속성 계층에서 접근하며 점점 해당 계층이 비대해지는 예를 보여줌.
- TODO 근데, 이런 예는 구체적으로 어떤 것이 있는지 아직은 잘 이해가 안됨.

## 점점 테스트하기 어려워짐 (It Grows Hard to Test)

- 컨트롤러에서 엔티티가 등장하는 경우도 있는데 이는 웹 계층에서 한단계 건너 뛰고 바로 영속화 계층으로의 접근임. 이는 두 가지 문제가 있음.
- 첫째는 도메인 로직이 웹 계층에 드러남.
- 두번째는 테스트에 관한 것. 웹 레이어를 테스트할 때 영속화에 관한 부분까지 목킹해야 하기 때문에 테스트의 복잡도가 높아짐.

## 유즈케이스가 잘 드러나지 않음 (It Hides the Use Cases)

- 보통 새 기능을 만드는 것 보다 기존 코드를 고치는게 더 시간이 걸림.
- 이는 꼭 '레거시' 라고 부르는 코드 베이스뿐만이 아님. 특정 유즈케이스에 대한 첫번째 구현이 완료된 후도 해당 됨.
- 계층 아키텍처는 도메인 로직은 다양한 계층에 흩어져 있을 수도 있음. 앞에서 이야기 한 예시처럼 간단한 도메인 로직이라 웹 계층에서 구현해버리거나, 도메인 계층과 영속성 계층에서 접근하기 위해 영속 계층에 도메인 로직을 구현해 버리거나.
- 또한 계층 아키텍처는 도메인 서비스의 크기(width) 에 대한 규칙이 존재하지 않음.
- 책의 예제는 두 개의 컨트롤러가 의존하고, 세 개의 레파지토리에 의존하는 수평적으로 거대한 서비스 클래스를 소개.
- 이는 비즈니스 유즈케이스를 파악하기 어려울 뿐만 아니라 테스트도 어렵게 함.

## 병렬적 개발 진행을 어렵게 함 (It Makes Parallel work Difficult)

- 맨먼스 미신에서 인력을 더 투입한다면 일정은 더 늦어질것이라는 말이 있음.
- 하지만 저자는 healthy scale 에서는 인력이 더 투입되고 올바르게 프로젝트가 매니징 된다면 분명이 빨라질 수 있다고 함.
- 또한 아키텍처에서도 병렬적으로 일이 진행될 수 있는 구조여야 하는데 계층 아키텍처는 이에 어려움이 있음.
- 예컨대 하나의 유즈케이스에 대한 한 명은 웹 계층, 한 명은 도메인 계층, 나머지 한명은 영속성 계층 이런식으로 나눌수가 없음. 최하위의 영속성 계층이 먼저 구현되어야 하기 때문.
- 영속성 계층의 실제 구현까지 기다릴 필요 없이 인터페이스에 대고 프로그래밍 할 할 수 있지만, 저자는 앞 선 예제들처럼 영속성 계층에 도메인 로직이 짬뽕되어 있는 경우, 하나 이상의 유즈케이스가 섞인 비대한 서비스를 기준으로 이야기 함.


# Chapter2. Inverting Dependencies

## 단일 책임 원칙

- 다른 OOP 책에서도 많이 이야기 했던 내용. 단일 책임 원칙은 변경의 이유가 오직 한가지 여야 한다는 것.
- 하지만 안타깝게도 컴포넌트와 컴포넌트간의 의존성으로 인해 변경이 유발되기도 함.
- 예컨대 A → B, C → E 의 의존 흐름을 가졌을 때, E 는 다른 컴포넌의 변경에 영향 받지 않지만 A 는 B, C, E 의 변경에 영향을 받을 수 있음.
- 코드베이스가 커지면서 컴포넌트의 변경 이유는 점점 많아짐 (물론 잘못 만들었을때).

## 의존성 역전 원칙

- 앞 장의 예시 중 영속성 계층의 엔티티를 같은 계층의 레파지토리가, 상위 계층의 서비스가 엔티티와 레파지토리를 의존해서 순환 의존성을 가졌음 (figure 1.2)

![https://user-images.githubusercontent.com/13076271/101277093-2a3ba800-37f5-11eb-8e42-d2a3adf2b160.png](https://user-images.githubusercontent.com/13076271/101277093-2a3ba800-37f5-11eb-8e42-d2a3adf2b160.png)

- 의존성 역전 원칙 적용을 위해 도메인 계층에 레파지토리 인터페이스를 만들고 구현은 영속성 계층에서 함으로써 의존성을 역전 시킴.
- 여기서 눈여겨 볼 점은 도메인 계층의 엔티티(도메인 객체) 와 영속성 계층의 엔티티가 구분된다는 것. 이전에 이에 대해 고민하기도 했었음. [TIL: Domain Model And Persistence Model](https://github.com/iamkyu/TIL/blob/master/til/2019q2.md#domain-model-and-persistence-model)
- 이는 도메인 계층을 다른 것으로부터 완전히 독립시키기 위한 비용이기도 함.

## 클린아키텍처와 육각아키텍처 (Clean Architecture & Hexagonal Architecture)

- 로버트 C 마틴이 소개한 클린아키텍처와 콕번의 육각아키텍처에 대한 소개

# Chapter 3. Orginizing Code

- 프로젝트가 시작하면 가장 먼저 패키지 구조를 잡음.
- 프로젝트가 진행되는 동안 상황은 바빠지고 이곳저곳에서 보기 좋은 패키지 구조는 단지 구조화되지 않은 엉망인 코드의 퍼사드일뿐이라는 것을 깨달음. 어떤 패키지의 클래스들은 접근하지 않아야 하는 다른 패키지의 클래스들을 임포트해서 사용하기도 함.

## 계층 기반 패키지

![https://user-images.githubusercontent.com/13076271/101279386-4b0bf980-3805-11eb-9cde-cf48fc2d6ab7.png](https://user-images.githubusercontent.com/13076271/101279386-4b0bf980-3805-11eb-9cde-cf48fc2d6ab7.png)

- DI 를 적용한 domain, persistence, web 으로 구분한 패키지 구조 소개
- 그리고 이 구조의 두가지 문제를 설명.
  - 1) 도메인 기능간에 패키지 경계가 없음. 만약 사용자 관리 기능을 추가 한다면 현재의 패키지 구조에 UserController - UserService - UserRepository - User 를 추가할 것임. 이렇게 계속 추가됨으로써 패키지는 엉망이 됨.
  - 2) 유즈 케이스가 명확히 드러나지 않음. AccountService 는 뭘 하는걸까? 정확한 어떤 기능에 관한 로직을 찾고자 할 때 혼란스러움.

## 기능 단위 패키지

![https://user-images.githubusercontent.com/13076271/101280215-3fbbcc80-380b-11eb-8b13-daaf323aec2d.png](https://user-images.githubusercontent.com/13076271/101280215-3fbbcc80-380b-11eb-8b13-daaf323aec2d.png)

- 계층 기반 패키지와 달리 기능 단위로 패키지. account 라는 패키지 아래 controller, service, repository, entity 가 모두 존재.
- account 아래 모든 컴포넌트들의 가시성은 package-private. 다른 기능과 의존성이 섞이지 않음.
- 계층 기반 패키지의 단점을 어느 정도 보완했지만 이 방식 역시 단점이 존재.
- 외부로 in, out 되는 부분을 식별하기 어렵고 DI 를 적용하긴 했지만 한 패키지에 섞여 있기 때문에 도메인 코드에 구체적인 영속성 코드가 침범하는 실수를 범하기 쉬움.

## An Architecturally Expressive Package Structure

![https://user-images.githubusercontent.com/13076271/101280234-58c47d80-380b-11eb-8d5e-698af3bd0e1c.png](https://user-images.githubusercontent.com/13076271/101280234-58c47d80-380b-11eb-8d5e-698af3bd0e1c.png)

- 이 구조는 architecture-code-gap 또는 [model-code-gap](https://www.ben-morris.com/most-architecture-diagrams-are-useless/) 이라고 불리는 아키텍처와 코드의 간극을 극복하는데 굉장한 도움이 됨.
- 이 구조는 굉장히 많은 패키지를 가지고 있어 복잡하지만 각 패키지의 목적이 명확하여 수정이 필요할 때 어디를 손대야 할 지 파악이 쉬움. 가시성 역시 구분되어 침범하지 말아야 할 패키지를 침범 할 걱정을 하지 않아도 됨.
- 또한 DI 를 통해 도메인 로직이 in, out 어댑터에 직접적으로 의존하지 않음.
- DDD 컨셉을 반영하는 구조이기도 함.
- 책의 예제 소스코드 https://github.com/thombergs/buckpal
