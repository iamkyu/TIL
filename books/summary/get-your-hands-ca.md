# Get Your Hands Dirty on Clean Architecture

> 톰홈버그스 저 | Packt | 2019.


![book-cover](https://user-images.githubusercontent.com/13076271/101275124-9f53b100-37e6-11eb-9ac3-46fb8b4d493b.png)

[책 구매하기](https://www.amazon.com/Hands-Dirty-Clean-Architecture-hands-ebook/dp/B07YFS3DNF/ref=sr_1_1?dchild=1&keywords=Get+Your+Hands+Dirty+on+Clean+Architecture&qid=1607242420&sr=8-1)



***<u>본 내용은 책 내용에 대한 개인적 이해를 바탕으로 한 요약과 생각이므로 정확한 내용은 반드시 책을 참고하길 권장함.</u>***

- 대부분 경험해봤을, 경험하고 있을 웹 - 도메인 - 영속 계층 으로 이뤄진 전통적인 계층 아키텍처 (웹)
- 계층화는 굉장히 견고한 아키텍처 패턴. 이를 잘 지킨다면 도메인 계층에 영향 없이 웹과 영속 계층을  교체할 수 있고, 기존 기능에 영향 없이 새 기능을 추가할 수 도 있음.
- 그러나 저자의 경험에 계층 아키텍처는 개방된 측면을 너무 많이 가지고 있어 시간이 지남에 따라 점점 아키텍처가 오염되고 소프트웨어를 바꾸기 어렵게 만듬.

## 데이터베이스 중심 설계 (It Promotes Database-Driven Design)

- 전통적인 계층 구조의 기반에서 모든 레이어는 영속 계층 위에 쌓임.
- 이런 의존성의 흐름에 따라 우리는 핵심 비즈니스 로직 보다 데이터베이스에 어떤 값이 저장할지 먼저 고민함. 즉 상태에 관한 고민. 계층 아키텍처에서 이런 의식의 흐름은 의존 방향에 따라 자연스럽기도 함.
- 도메인의 핵심은 '행동'. '상태'도 중요하지만 '행동'이 핵심임.
- 따라서 우리는 다른 어떤 것보다 도메인 로직 설계가 선행되어야 함.
- 또한 ORM 프레임워크와 계층 아키텍처가 함께 사용될 때, 비즈니스 규칙은 영속화와 관련 내용이 드러나기 쉬움. 레이지로딩, 트랜잭션, 캐시 플러시(flush) 등.

## 침범하기 쉬움 (Its' Prone to Shortcuts)

- 계층 아키텍처의 규칙은 오직 하나뿐임, 명확히 구분 된 계층. 각 컴포넌트는 자신의 계층 또는 하위 계층만 접근 가능함. 하지만 아키텍처가 이런 규칙을 강제하진 않음.
- 따라서 원한다면 하위 계층에서 상위 계층의 특정 컴포넌트에 접근해야 할 때 상위 계층 컴포넌트를 하위 계층으로 이동 시켜버릴 수도 있음.
- 그리고 이는 깨진 유리창 효과를 만들어냄.
- 책의 예제는 Helper, Util 이라는 이름을 가진  계층이 애매한 컴포넌트들을 도메인 계층에서 사용하기 위해 영속성 계층에 둔 사례를 듬.
- 이런 침범을 방지하기 위해 아키텍처 규칙을 강제하지 않는 이상 계층 아키텍처는 최선이 아니라고 함. 여기서 강제는 시니어 개발자의 코드 리뷰 같은 것이 아님. 규칙을 어기면 빌드 조차 되지 않는 것.

## 점점 테스트하기 어려워짐 (It Grows Hard to Test)

- 책의 예제는 필드가 하나 뿐인 간단한 엔티티를 웹계층에서 영속계층으로 바로 접근 (도메인 계층 건너뜀). 이는 두 가지 문제가 있음.
- 첫째, 현재는 괜찮지만 미래에 유스케이스가 더 복잡해진다면? 앞에서 얘기한 깨진 유리창 효과로 웹 계층에 유스케이스가 드러난다면?
- 두번째는 테스트에 관한 것. 웹 레이어를 테스트할 때 영속화에 관한 부분까지 목킹해야 하기 때문에 테스트의 복잡도가 높아지고 귀찮아짐.

## 유스케이스가 잘 드러나지 않음 (It Hides the Use Cases)

- 보통 새 기능을 만드는 것 보다 기존 코드를 고치는게 더 시간이 걸림.
- 이는 꼭 '레거시' 라고 부르는 코드 베이스뿐만이 아님. 특정 유스케이스에 대한 첫번째 구현이 완료된 후도 해당 됨.
- 계층 아키텍처는 도메인 로직은 다양한 계층에 흩어져 있을 수도 있음. 앞에서 이야기 한 예시처럼 간단한 도메인 로직이라 웹 계층에서 구현해버리거나, 도메인 계층과 영속성 계층에서 접근하기 위해 영속 계층에 도메인 로직을 구현해 버리거나.
- 또한 계층 아키텍처는 도메인 서비스의 크기(width) 에 대한 규칙이 존재하지 않음.
- 책의 예제는 두 개의 컨트롤러가 의존하고, 세 개의 레파지토리에 의존하는 수평적으로 거대한 서비스 클래스를 소개. 즉 여러 유스케이스가 하나의 서비스에 섞여 있는 것.
- 이는 비즈니스 유스케이스를 파악하기 어려울 뿐만 아니라 테스트도 어렵게 함.

## 병렬적 개발 진행을 어렵게 함 (It Makes Parallel work Difficult)

- 맨먼스 미신에서 인력을 더 투입한다면 일정은 더 늦어질것이라는 말이 있음.
- 하지만 저자는 healthy scale 에서는 인력이 더 투입되고 올바르게 프로젝트가 매니징 된다면 분명이 빨라질 수 있다고 함.
- 또한 아키텍처에서도 병렬적으로 일이 진행될 수 있는 구조여야 하는데 계층 아키텍처는 이에 어려움이 있음.
- 예컨대 하나의 유스케이스에 대한 한 명은 웹 계층, 한 명은 도메인 계층, 나머지 한명은 영속성 계층 이런식으로 나눌수가 없음. 최하위의 영속성 계층이 먼저 구현되어야 하기 때문.
- 영속성 계층의 실제 구현까지 기다릴 필요 없이 인터페이스에 대고 프로그래밍 할 할 수 있지만, 저자는 앞 선 예제들처럼 영속성 계층에 도메인 로직이 짬뽕되어 있는 경우, 하나 이상의 유스케이스가 섞인 비대한 서비스를 기준으로 이야기 함.

# Chapter2. Inverting Dependencies

## 단일 책임 원칙

- 다른 OOP 책에서도 많이 이야기 했던 내용. 단일 책임 원칙은 변경의 이유가 오직 한가지 여야 한다는 것.
- 하지만 안타깝게도 컴포넌트와 컴포넌트간의 의존성으로 인해 변경이 유발되기도 함.
- 예컨대 A → B, C → E 의 의존 흐름을 가졌을 때, E 는 다른 컴포넌의 변경에 영향 받지 않지만 A 는 B, C, E 의 변경에 영향을 받을 수 있음.
- 코드베이스가 커지면서 컴포넌트의 변경 이유는 점점 많아짐 (물론 잘못 만들었을때).

## 의존성 역전 원칙

- 앞 장의 예시 중 영속성 계층의 엔티티를 같은 계층의 레파지토리가, 상위 계층의 서비스가 엔티티와 레파지토리를 의존해서 순환 의존성을 가졌음 (figure 1.2)

![https://user-images.githubusercontent.com/13076271/101277093-2a3ba800-37f5-11eb-8e42-d2a3adf2b160.png](https://user-images.githubusercontent.com/13076271/101277093-2a3ba800-37f5-11eb-8e42-d2a3adf2b160.png)

- 의존성 역전 원칙 적용을 위해 도메인 계층에 레파지토리 인터페이스를 만들고 구현은 영속성 계층에서 함으로써 의존성을 역전 시킴.
- 여기서 눈여겨 볼 점은 도메인 계층의 엔티티(도메인 객체) 와 영속성 계층의 엔티티가 구분된다는 것. 이전에 이에 대해 고민하기도 했었음. [TIL: Domain Model And Persistence Model](https://github.com/iamkyu/TIL/blob/master/til/2019q2.md#domain-model-and-persistence-model)
- 이는 도메인 계층을 다른 것으로부터 완전히 독립시키기 위한 비용이기도 함.

## 클린아키텍처와 육각아키텍처 (Clean Architecture & Hexagonal Architecture)

- 로버트 C 마틴이 소개한 클린아키텍처와 콕번의 육각아키텍처에 대한 소개
- [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)
- [https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- 육각형에 특별한 의미는 없음. 단지 애플리케이션 다양한 어댑터들이 연결될 수 있다는걸 나타내기 위해 사각형 대신 육각형으로 나타냈다고 함.

# Chapter 3. Orginizing Code

- 프로젝트가 시작하면 가장 먼저 패키지 구조를 잡음.
- 프로젝트가 진행되는 동안 상황은 바빠지고 이곳저곳에서 보기 좋은 패키지 구조는 단지 구조화되지 않은 엉망인 코드의 퍼사드일뿐이라는 것을 깨달음. 어떤 패키지의 클래스들은 접근하지 않아야 하는 다른 패키지의 클래스들을 임포트해서 사용하기도 함.

## 계층 기반 패키지

![https://user-images.githubusercontent.com/13076271/101279386-4b0bf980-3805-11eb-9cde-cf48fc2d6ab7.png](https://user-images.githubusercontent.com/13076271/101279386-4b0bf980-3805-11eb-9cde-cf48fc2d6ab7.png)

- DI 를 적용한 domain, persistence, web 으로 구분한 패키지 구조 소개
- 그리고 이 구조의 두가지 문제를 설명.
- 1) 도메인 기능간에 패키지 경계가 없음. 만약 사용자 관리 기능을 추가 한다면 현재의 패키지 구조에 UserController - UserService - UserRepository - User 를 추가할 것임. 이렇게 계속 추가됨으로써 패키지는 엉망이 됨.
- 2) 유스 케이스가 명확히 드러나지 않음. AccountService 는 뭘 하는걸까? 정확한 어떤 기능에 관한 로직을 찾고자 할 때 혼란스러움.
- 3) web, persistence 패키지만 보고는 in, out 을 구분할 수 없다고는 하는데 딱히 공감은 안됨.

## 기능 단위 패키지

![https://user-images.githubusercontent.com/13076271/101280215-3fbbcc80-380b-11eb-8b13-daaf323aec2d.png](https://user-images.githubusercontent.com/13076271/101280215-3fbbcc80-380b-11eb-8b13-daaf323aec2d.png)

- 계층 기반 패키지와 달리 기능 단위로 패키지. account 라는 패키지 아래 controller, service, repository, entity 가 모두 존재.
- AccountService 도 SendMoneyService 로 이름이 바뀜. 클래스 이름으로 유스케이스를 바로 찾아낼 수 있음.
- account 아래 모든 컴포넌트들의 가시성은 package-private. 다른 기능과 의존성이 섞이지 않음.
- 계층 기반 패키지의 단점을 어느 정도 보완했지만 이 방식 역시 단점이 존재.
- 외부로 in, out 되는 부분을 식별하기 어렵고 DI 를 적용하긴 했지만 한 패키지에 섞여 있기 때문에 도메인 코드에 영속성 코드가 침범하는 실수를 범하기 쉬움.

## 아키텍처를 드러내는 패키지

![https://user-images.githubusercontent.com/13076271/101280234-58c47d80-380b-11eb-8d5e-698af3bd0e1c.png](https://user-images.githubusercontent.com/13076271/101280234-58c47d80-380b-11eb-8d5e-698af3bd0e1c.png)

- 이 구조는 architecture-code-gap 또는 [model-code-gap](https://www.ben-morris.com/most-architecture-diagrams-are-useless/) 이라고 불리는 아키텍처와 코드의 간극을 극복하는데 굉장한 도움이 됨.
- 이 구조는 굉장히 많은 패키지를 가지고 있어 복잡하지만 각 패키지의 목적이 명확하여 수정이 필요할 때 어디를 손대야 할 지 파악이 쉬움. 가시성 역시 구분되어 침범하지 말아야 할 패키지를 침범 할 걱정을 하지 않아도 됨.
- 상위 레벨의 account 라는 패키지명은 Account 에 관한 유스케이스가 모여 있다는걸 알 수 있게 함
- 차상위 레벨중 application  패키지의 SendMoneyService 는 incoming port 인터페이스를 구현함. 반면, out 아래 인터페이스의 구현은 영속성 계층에서 하게 될 것임.
- 차상위 레벨 중 adapter 패키지는 in, out 의 구현체가 존재함.
- 핵사고날 아키텍처를 그대로 드러내는 이 패키지 구조는 개발자간의 커뮤니케이션을 쉽게함.

```
4장 부터는 예제소스와 보는 것이 좋음 https://github.com/thombergs/buckpal
```

# Chapter4. Implementing a Use Case

Account 엔티티 예제

- 출금, 입금과 같은 도메인의 역할을 수행.

유스케이스가 해야 하는 일은 다음과 같이 소개.

1. 입력을 받음
2. 비지니스 규칙을 검사함
3. 모델의 상태를 변경
4. 결과를 반환

유스케이스의 역할

- 저자는 유스케이스는 입력값 검증 로직으로 '오염' 시키면 안된다고 생각. 유스케이스는 비즈니스 규칙을 검사해야 함
- 이런 비즈니스 규칙 검사 책임은 엔티티와 유스케이스가 적절히 나눠가져야 함
- 기본적으로 도메인 엔티티가 규칙을 알되, 어렵다면(더 많은 컨텍스트가 필요하거나?) 유스케이스에서 수행

그렇다면 입력 검증은 어디서?

- 입력 값 검증은 입력 모델 안에서 수행하라고 이야기 함
- 예제코드에서는 `SendMoneyCommand`
- 입력 모델을 불변하게 만들고 beanvalidation 스펙(+스프링의 검증로직) 을 통해 입력 검증 후 유스케이스는에 넘김

입력 검사, 비즈니스 규칙 검사의 구분

- 비지니스 규칙 감사는 현재 도메인 모델의 상태가 필요함, 입력 검사는 아님
- 입력 검사는 Notnall 어노테이션과 같이 선언적으로 나타낼 수 있는 반면 비지니스 규칙은 컨텍스트가 좀 더 필요
- 입력 검사는 구문 유효성 검사(?)라고 할 수 있고 비지니스 규칙 검사는 의미론 유효성 검사라고 할 수 있음

읽기만 하는 유스케이스는?

- 애플리케이션의 핵심 관점에서 읽기만 하는건 단지 데이터를 질의 하는 것일 뿐.
- 유스케이스는 아님.
- CQS 또는 CQRS 라고 알려진 패턴을 사용.

그외

- 빌더의 문제와 생성자를 통한 객체 생성의 장점
- 다른 유스케이스에서는 다른 입,출력 모델을 사용
- Rich 도메인 모델, Anemic 도메인 모델

# Chapter5. Implementing a Web Adapter

- 예제 코드의 특이점은 Web 과 Service 패키지 사이에 Port 라는 한 계층이 더 존재함
- 저자가 설명하길 Port 는 애플리케이션의 코어가 어떤 외부와 상호작용하는지를 명확히 드러낸다고 함
- 웹어댑터의 크기도 유스케이스 별로 나누길 추천함

웹어댑터의 책임은

1. HTTP 요청을 자바 객체로 맵핑
2. 인증 체크
3. 입력 검증
4. 입력을 유스케이스 인풋 모델로 맵핑
5. 유스케이스 호출
6. 반환값을 HTTP 메세지로 맵핑
7. HTTP 응답을 반환

웹 어댑터가 많은 책임을 가지고 있기도 하지만 이것들은 애플리케이션 레이어에서 가지지 말아야 할 책임들이기도 함.

# Chapter6. Implementing a Persistence Adapter

- 예제코드에서 웹 어댑터에서와 마찬가지고 Service 와 Persistence 사이에 Port (out) 계층이 존재
- 인상적이었던 것은 Repository 자체를 서비스 계층에 노출하지 않으면서 Adapter 를 통해 필요한 인터페이스만 노출하도록 한 것
- 트랜잭션 처리의 가장 쉬운 방법은 스프링에서 제공하는 Transactional 어노테이션을 사용하는 것. 서비스계층이 특정 프레임워크 종속되지 않도록 하고 싶다면 AOP 방식으로 직접 처리할 수도.

# Chapter7. Testing Architecture Elements

저자는 테스트 피라미드를 소개하고 피라미드는 유닛 테스트 - 통합테스트 - 시스템 테스트 순.

각 테스트의 정의는 컨텍스트마다 다를 수 있고 저자는 앞서 계속 이야기한 육각 아키텍처를 기준으로 설명.

- 유닛테스트: 일반적으로 단일 객체를 테스트 함. 만약 다른 객체에 의존성이 있다면 mock 으로 대체하여 해당 객체의 행동을 테스트 간 시뮬레이션 할 수 있음. (mock 에 대한 논란은 많지만 일단 pass)
- 통합테스트: 여러 객체간의 상호 작용을 확인. 진입점인 클래스의 인터페이스트를 통해 입력하고 예상한대로 상호작용하고 출력하는지 확인. 두 개의 계층을 넘나 듬.
- 시스템테스트: 애플리케이션을 구성하는 모든 객체의 상호 작용을 확인. 유스케이스가 전 계층에 걸쳐 예상대로 상호작용 하는지 확인

책의 예시로

- 유닛테스트
    - 도메인 엔티티 테스트
    - 유스케이스 테스트: 유스케이스를 구현한 서비스 클래스는 상태를 가지지 않으므로 테스트 결과로 상태가 아닌 행위를 확인함. 이는 테스트 대상의 상호작용 뿐만 아니라 코드 구조의 변경에도 취약함. 즉, 테스트 대상 코드가 리팩토링 된다면 테스트도 수정되어야 할 가능성 높음.
- 통합테스트
    - 웹어댑터: 컨트롤러에 대해서만 테스트 하지만 유닛테스트가 아닌 이유는 WebMvcTest 어노테이션을 통해 수많은 객체 상호작용이 일어나기 때문.
    - 영속어댑터: 데이터베이스와 상호작용이 일어나는 테스트. 하지만 DateJpaTest 를 이용하면 기본적으로 인메모리 DB 를 사용하고 이는 운영환경과 다소 차이가 있을 수 있음. 이를 극복하기 TestContainer 와 같은 기술을 사용할 수 있음.
- 시스템테스트
    - 유스케이스를 모든 계층이 상호작용하는 테스트를 수행. 유닛테스트에서 유스케이스 테스트는 mockMvc 를 사용했지만 여기서는 TestRestTemplate 을 사용. 즉 진짜 HTTP 요청을 사용. 또한 예제 코드에서 인상적인건 각종 데이터 생성, 핼퍼 로직들은 모두 메서드에 숨기고 도메인 의미를 나타내는 이름을 부여. 이로 인해 테스트 코드는 더 가독성이 좋아짐.

    테스트는 얼만큼 충분한가?

    - 라인 커버리지는 좋은 측정 지표가 X
    - 릴리즈때 마음이 편할 수 있을만큼 테스트하라고 함.
    - 버그가 발생하면 해당 버그를 커버하는 테스트를 추가.
    - 반면, 필드 하나를 추가했는데  테스트를 수정하느라 많은 시간을 보낸다면 뭔가 잘못된 것. 코드 구조 변경에 테스트가 너무 취약한 것.


# Chapter8. Mapping Between Boundaries

- 각 계층의 경계마다 다른 모델을 사용하는 방법부터 모두 같은 모델을 사용하는 전략까지. 4가지의 맵핑 전략과 그에 따른 장단점 소개
- 인상 깊은 구절은 "the strategy that was the best for the job yesterday might not still be the best for the job today"
