# Get Your Hands Dirty on Clean Architecture

> 톰홈버그스 저 | Packt | 2019.


![book-cover](https://user-images.githubusercontent.com/13076271/101275124-9f53b100-37e6-11eb-9ac3-46fb8b4d493b.png)

[책 구매하기](https://www.amazon.com/Hands-Dirty-Clean-Architecture-hands-ebook/dp/B07YFS3DNF/ref=sr_1_1?dchild=1&keywords=Get+Your+Hands+Dirty+on+Clean+Architecture&qid=1607242420&sr=8-1)



***<u>본 내용은 책 내용에 대한 개인적 이해를 바탕으로 한 요약과 생각이므로 정확한 내용은 반드시 책을 참고하길 권장함.</u>***

- 대부분 경험해봤을, 경험하고 있을 웹 - 도메인 - 영속 계층 으로 이뤄진 전통적인 계층 아키텍처 (웹)
- 계층화는 굉장히 견고한 아키텍처 패턴. 이를 잘 지킨다면 도메인 계층에 영향 없이 웹과 영속 계층을  교체할 수 있고, 기존 기능에 영향 없이 새 기능을 추가할 수 도 있음.
- 그러나 저자의 경험에 계층 아키텍처는 개방된 측면을 너무 많이 가지고 있어 시간이 지남에 따라 점점 아키텍처가 오염되고 소프트웨어를 바꾸기 어렵게 만듬.

## 데이터베이스 중심 설계 (It Promotes Database-Driven Design)

- 전통적인 계층 구조의 기반에서 모든 레이어는 영속 계층 위에 쌓임.
- 이런 의존성의 흐름에 따라 우리는 핵심 비즈니스 로직 보다 데이터베이스에 어떤 값이 저장할지 먼저 고민함. 즉 상태에 관한 고민. 계층 아키텍처에서 이런 의식의 흐름은 의존 방향에 따라 자연스럽기도 함.
- 도메인의 핵심은 '행동'. '상태'도 중요하지만 '행동'이 핵심임.
- 따라서 우리는 다른 어떤 것보다 도메인 로직 설계가 선행되어야 함.
- 또한 ORM 프레임워크와 계층 아키텍처가 함께 사용될 때, 비즈니스 규칙은 영속화와 관련 내용이 드러나기 쉬움. 레이지로딩, 트랜잭션, 캐시 플러시(flush) 등.

## 침범하기 쉬움 (Its' Prone to Shortcuts)

- 계층 아키텍처의 규칙은 오직 하나뿐임, 명확히 구분 된 계층. 각 컴포넌트는 자신의 계층 또는 하위 계층만 접근 가능함. 하지만 아키텍처가 이런 규칙을 강제하진 않음.
- 따라서 원한다면 하위 계층에서 상위 계층의 특정 컴포넌트에 접근해야 할 때 상위 계층 컴포넌트를 하위 계층으로 이동 시켜버릴 수도 있음.
- 그리고 이는 깨진 유리창 효과를 만들어냄.
- 책의 예제는 Helper, Util 이라는 이름을 가진  계층이 애매한 컴포넌트들을 도메인 계층에서 사용하기 위해 영속성 계층에 둔 사례를 듬.
- 이런 침범을 방지하기 위해 아키텍처 규칙을 강제하지 않는 이상 계층 아키텍처는 최선이 아니라고 함. 여기서 강제는 시니어 개발자의 코드 리뷰 같은 것이 아님. 규칙을 어기면 빌드 조차 되지 않는 것.

## 점점 테스트하기 어려워짐 (It Grows Hard to Test)

- 책의 예제는 필드가 하나 뿐인 간단한 엔티티를 웹계층에서 영속계층으로 바로 접근 (도메인 계층 건너뜀). 이는 두 가지 문제가 있음.
- 첫째, 현재는 괜찮지만 미래에 유스케이스가 더 복잡해진다면? 앞에서 얘기한 깨진 유리창 효과로 웹 계층에 유스케이스가 드러난다면?
- 두번째는 테스트에 관한 것. 웹 레이어를 테스트할 때 영속화에 관한 부분까지 목킹해야 하기 때문에 테스트의 복잡도가 높아지고 귀찮아짐.

## 유스케이스가 잘 드러나지 않음 (It Hides the Use Cases)

- 보통 새 기능을 만드는 것 보다 기존 코드를 고치는게 더 시간이 걸림.
- 이는 꼭 '레거시' 라고 부르는 코드 베이스뿐만이 아님. 특정 유스케이스에 대한 첫번째 구현이 완료된 후도 해당 됨.
- 계층 아키텍처는 도메인 로직은 다양한 계층에 흩어져 있을 수도 있음. 앞에서 이야기 한 예시처럼 간단한 도메인 로직이라 웹 계층에서 구현해버리거나, 도메인 계층과 영속성 계층에서 접근하기 위해 영속 계층에 도메인 로직을 구현해 버리거나.
- 또한 계층 아키텍처는 도메인 서비스의 크기(width) 에 대한 규칙이 존재하지 않음.
- 책의 예제는 두 개의 컨트롤러가 의존하고, 세 개의 레파지토리에 의존하는 수평적으로 거대한 서비스 클래스를 소개. 즉 여러 유스케이스가 하나의 서비스에 섞여 있는 것.
- 이는 비즈니스 유스케이스를 파악하기 어려울 뿐만 아니라 테스트도 어렵게 함.

## 병렬적 개발 진행을 어렵게 함 (It Makes Parallel work Difficult)

- 맨먼스 미신에서 인력을 더 투입한다면 일정은 더 늦어질것이라는 말이 있음.
- 하지만 저자는 healthy scale 에서는 인력이 더 투입되고 올바르게 프로젝트가 매니징 된다면 분명이 빨라질 수 있다고 함.
- 또한 아키텍처에서도 병렬적으로 일이 진행될 수 있는 구조여야 하는데 계층 아키텍처는 이에 어려움이 있음.
- 예컨대 하나의 유스케이스에 대한 한 명은 웹 계층, 한 명은 도메인 계층, 나머지 한명은 영속성 계층 이런식으로 나눌수가 없음. 최하위의 영속성 계층이 먼저 구현되어야 하기 때문.
- 영속성 계층의 실제 구현까지 기다릴 필요 없이 인터페이스에 대고 프로그래밍 할 할 수 있지만, 저자는 앞 선 예제들처럼 영속성 계층에 도메인 로직이 짬뽕되어 있는 경우, 하나 이상의 유스케이스가 섞인 비대한 서비스를 기준으로 이야기 함.

# Chapter2. Inverting Dependencies

## 단일 책임 원칙

- 다른 OOP 책에서도 많이 이야기 했던 내용. 단일 책임 원칙은 변경의 이유가 오직 한가지 여야 한다는 것.
- 하지만 안타깝게도 컴포넌트와 컴포넌트간의 의존성으로 인해 변경이 유발되기도 함.
- 예컨대 A → B, C → E 의 의존 흐름을 가졌을 때, E 는 다른 컴포넌의 변경에 영향 받지 않지만 A 는 B, C, E 의 변경에 영향을 받을 수 있음.
- 코드베이스가 커지면서 컴포넌트의 변경 이유는 점점 많아짐 (물론 잘못 만들었을때).

## 의존성 역전 원칙

- 앞 장의 예시 중 영속성 계층의 엔티티를 같은 계층의 레파지토리가, 상위 계층의 서비스가 엔티티와 레파지토리를 의존해서 순환 의존성을 가졌음 (figure 1.2)

![https://user-images.githubusercontent.com/13076271/101277093-2a3ba800-37f5-11eb-8e42-d2a3adf2b160.png](https://user-images.githubusercontent.com/13076271/101277093-2a3ba800-37f5-11eb-8e42-d2a3adf2b160.png)

- 의존성 역전 원칙 적용을 위해 도메인 계층에 레파지토리 인터페이스를 만들고 구현은 영속성 계층에서 함으로써 의존성을 역전 시킴.
- 여기서 눈여겨 볼 점은 도메인 계층의 엔티티(도메인 객체) 와 영속성 계층의 엔티티가 구분된다는 것. 이전에 이에 대해 고민하기도 했었음. [TIL: Domain Model And Persistence Model](https://github.com/iamkyu/TIL/blob/master/til/2019q2.md#domain-model-and-persistence-model)
- 이는 도메인 계층을 다른 것으로부터 완전히 독립시키기 위한 비용이기도 함.

## 클린아키텍처와 육각아키텍처 (Clean Architecture & Hexagonal Architecture)

- 로버트 C 마틴이 소개한 클린아키텍처와 콕번의 육각아키텍처에 대한 소개
- [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)
- [https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- 육각형에 특별한 의미는 없음. 단지 애플리케이션 다양한 어댑터들이 연결될 수 있다는걸 나타내기 위해 사각형 대신 육각형으로 나타냈다고 함.

# Chapter 3. Orginizing Code

- 프로젝트가 시작하면 가장 먼저 패키지 구조를 잡음.
- 프로젝트가 진행되는 동안 상황은 바빠지고 이곳저곳에서 보기 좋은 패키지 구조는 단지 구조화되지 않은 엉망인 코드의 퍼사드일뿐이라는 것을 깨달음. 어떤 패키지의 클래스들은 접근하지 않아야 하는 다른 패키지의 클래스들을 임포트해서 사용하기도 함.

## 계층 기반 패키지

![https://user-images.githubusercontent.com/13076271/101279386-4b0bf980-3805-11eb-9cde-cf48fc2d6ab7.png](https://user-images.githubusercontent.com/13076271/101279386-4b0bf980-3805-11eb-9cde-cf48fc2d6ab7.png)

- DI 를 적용한 domain, persistence, web 으로 구분한 패키지 구조 소개
- 그리고 이 구조의 두가지 문제를 설명.
- 1) 도메인 기능간에 패키지 경계가 없음. 만약 사용자 관리 기능을 추가 한다면 현재의 패키지 구조에 UserController - UserService - UserRepository - User 를 추가할 것임. 이렇게 계속 추가됨으로써 패키지는 엉망이 됨.
- 2) 유스 케이스가 명확히 드러나지 않음. AccountService 는 뭘 하는걸까? 정확한 어떤 기능에 관한 로직을 찾고자 할 때 혼란스러움.
- 3) web, persistence 패키지만 보고는 in, out 을 구분할 수 없다고는 하는데 딱히 공감은 안됨.

## 기능 단위 패키지

![https://user-images.githubusercontent.com/13076271/101280215-3fbbcc80-380b-11eb-8b13-daaf323aec2d.png](https://user-images.githubusercontent.com/13076271/101280215-3fbbcc80-380b-11eb-8b13-daaf323aec2d.png)

- 계층 기반 패키지와 달리 기능 단위로 패키지. account 라는 패키지 아래 controller, service, repository, entity 가 모두 존재.
- AccountService 도 SendMoneyService 로 이름이 바뀜. 클래스 이름으로 유스케이스를 바로 찾아낼 수 있음.
- account 아래 모든 컴포넌트들의 가시성은 package-private. 다른 기능과 의존성이 섞이지 않음.
- 계층 기반 패키지의 단점을 어느 정도 보완했지만 이 방식 역시 단점이 존재.
- 외부로 in, out 되는 부분을 식별하기 어렵고 DI 를 적용하긴 했지만 한 패키지에 섞여 있기 때문에 도메인 코드에 영속성 코드가 침범하는 실수를 범하기 쉬움.

## 아키텍처를 드러내는 패키지

![https://user-images.githubusercontent.com/13076271/101280234-58c47d80-380b-11eb-8d5e-698af3bd0e1c.png](https://user-images.githubusercontent.com/13076271/101280234-58c47d80-380b-11eb-8d5e-698af3bd0e1c.png)

- 이 구조는 architecture-code-gap 또는 [model-code-gap](https://www.ben-morris.com/most-architecture-diagrams-are-useless/) 이라고 불리는 아키텍처와 코드의 간극을 극복하는데 굉장한 도움이 됨.
- 이 구조는 굉장히 많은 패키지를 가지고 있어 복잡하지만 각 패키지의 목적이 명확하여 수정이 필요할 때 어디를 손대야 할 지 파악이 쉬움. 가시성 역시 구분되어 침범하지 말아야 할 패키지를 침범 할 걱정을 하지 않아도 됨.
- 상위 레벨의 account 라는 패키지명은 Account 에 관한 유스케이스가 모여 있다는걸 알 수 있게 함
- 차상위 레벨중 application  패키지의 SendMoneyService 는 incoming port 인터페이스를 구현함. 반면, out 아래 인터페이스의 구현은 영속성 계층에서 하게 될 것임.
- 차상위 레벨 중 adapter 패키지는 in, out 의 구현체가 존재함.
- 핵사고날 아키텍처를 그대로 드러내는 이 패키지 구조는 개발자간의 커뮤니케이션을 쉽게함.

```
4장 부터는 예제소스와 보는 것이 좋음 https://github.com/thombergs/buckpal
```

# Chapter4. Implementing a Use Case

Account 엔티티 예제

- 출금, 입금과 같은 도메인의 역할을 수행.

유스케이스가 해야 하는 일은 다음과 같이 소개.

1. 입력을 받음
2. 비지니스 규칙을 검사함
3. 모델의 상태를 변경
4. 결과를 반환

유스케이스의 역할

- 저자는 유스케이스는 입력값 검증 로직으로 '오염' 시키면 안된다고 생각. 유스케이스는 비즈니스 규칙을 검사해야 함
- 이런 비즈니스 규칙 검사 책임은 엔티티와 유스케이스가 적절히 나눠가져야 함
- 기본적으로 도메인 엔티티가 규칙을 알되, 어렵다면(더 많은 컨텍스트가 필요하거나?) 유스케이스에서 수행

그렇다면 입력 검증은 어디서?

- 입력 값 검증은 입력 모델 안에서 수행하라고 이야기 함
- 예제코드에서는 `SendMoneyCommand`
- 입력 모델을 불변하게 만들고 beanvalidation 스펙(+스프링의 검증로직) 을 통해 입력 검증 후 유스케이스는에 넘김

입력 검사, 비즈니스 규칙 검사의 구분

- 비지니스 규칙 감사는 현재 도메인 모델의 상태가 필요함, 입력 검사는 아님
- 입력 검사는 Notnall 어노테이션과 같이 선언적으로 나타낼 수 있는 반면 비지니스 규칙은 컨텍스트가 좀 더 필요
- 입력 검사는 구문 유효성 검사(?)라고 할 수 있고 비지니스 규칙 검사는 의미론 유효성 검사라고 할 수 있음

읽기만 하는 유스케이스는?

- 애플리케이션의 핵심 관점에서 읽기만 하는건 단지 데이터를 질의 하는 것일 뿐.
- 유스케이스는 아님.
- CQS 또는 CQRS 라고 알려진 패턴을 사용.

그외

- 빌더의 문제와 생성자를 통한 객체 생성의 장점
- 다른 유스케이스에서는 다른 입,출력 모델을 사용
- Rich 도메인 모델, Anemic 도메인 모델
