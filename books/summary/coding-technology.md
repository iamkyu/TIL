# 코딩을 지탱하는 기술: 원리로 깨우치는 프로그래밍 기법

> [코딩을 지탱하는 기술 | 저자 니시오 히로카즈|역자 김완섭|비제이퍼블릭 |2013.10.17](http://book.naver.com/bookdb/book_detail.nhn?bid=7317474)

'이 책의 목적은 여러분의 `왜` 를 해결하는 것이다.' 책 뒷장에 나와 있는 말이다. 특정 문법이나 기술을 설명한 책이 아니다. 프로그래밍의 역사와 함께 거슬러 올라오며 어떤 기술들이 왜 등장했고 왜 필요했는지를 설명한다. 그 중 개인적으로 호기심을 많이 가지고 있는 객체지향에 관한 내용(11장 객체와 클래스)을 기록해둔다.



## 객체지향

**용어**는 모든 언어에서 공통적이지 않다. 같은 용어도 다른 프로그래밍 언어에서는 다른 의미가 된다.

- *class는 사용자 정의형을 만들기 위한 구조. OOP란 사용자 정의형과 상속을 사용한 프로그래밍이다.* - C++ 설계자 Bjarne Stroustrup
- *형(Type)에 반대하지는 않지만, 고생하지 않는 형 시스템을 본 적이 없다. 객체지향이란 상태를 가진 객체가 메시지를 주고 받아 커뮤니케이션 하는 것이다.* - Smalltalk의 설계자 Alan Kay



## 객체는 현실 세계의 모형

- *컴퓨터로 문제를 해결하기 위해 현실 세계의 '사물 `object`' 모형 `model`을 컴퓨터 안에 만들 필요가 있었다.* - ALGOL60의 설계자 Hoare



## 변수와 함수를 합쳐 모형을 만드는 법

### 방법 1. 모듈, 패키지

```perl
# Perl Language
{
	package Counter;
	my $count = 0;
	my $name = "참새";
	
    sub push{
    	$count++;
    	print "$name: $count 마리\n";
    }
    
    sub reset{
    	$count = 0;
    }
}

Counter:push; // 참새 1마리
Counter:push; // 참새 2마리
Counter:push; // 참새 3마리
Counter:reset; // 참새 리셋
Counter:push; // 참새 1마리
```

프로그램 안에는 함수나 변수가 대등한 관계로 여기 저기 흩어져 있음. 어떤 변수도 어떤 함수도 어디서든 동일하게 접근할 수 있지만, 이 중 **'상호 간의 연결성이 강한 그룹'** 

- 관련성이 높은 함수나 변수의 묶음을 명시하기 위해 모듈이라는 개념을 도입.

#### 문제점

- 함수나 모듈은 하나의 정의에 하나의 컴퓨터 상의 실체가 대응.
- 현실에서는 비슷한 사물이 복수 개(복수개의 인스턴스) 있다고 하는 상황이 존재. (위 예제의 경우 카운터A와 카운터B가 필요하다면?).
- 이를 구현하기 위해 모듈의 코드를 전부 똑같이 복사해 사용해야 한다면? 코드의 중복.



### 방법 2. 데이터를 별도로 저장

```perl
{
	package Counter;

    sub push{
    	my $values = shift;
        $values->{count}++;
        
        print "$values -> {count} 마리\n";
    }
}

# 해쉬를 만든다
my $counter1 = {"value" => 0};
my $counter2 = {"value" => 0};

Counter:push($counter1);
Counter:push($counter1);
Counter:push($counter2);
Counter:push($counter1);
```

패키지에 정의 된 소스 코드는 동일한 동작을 하도록 두고 해쉬를 사용하여 (상태)저장소를 별개로 분리.

```perl
{
	package Counter;
    sub new {
	    return {"vallue" => 0};
    }

    sub push{
    	my $values = shift;
        $values->{count}++;
        
        print "$values -> {count} 마리\n";
    }
}

# 초기화 처리를 패키지에 포함한다.
my $counter1 = Counter:new;
my $counter2 = Counter:new;

Counter:push($counter1);
Counter:push($counter1);
Counter:push($counter2);
Counter:push($counter1);
```

초기화 처리를 하는 `new` 라는 함수도 정의하여 패키지에 포함 (언어에 따라 용어 정의가 다르다! 자바에서는 new 예약어를 통해 생성자를 통해 초기화 하지만, 위 예제 new는 단지 직접 정의한 함수일 뿐이다.).

```javascript
function makeCounter() {
  return {
    count: 0,
    push: function() {
      this.count++;
      console.log(this.count+ "마리");
    }
  }
}
```

자바 스크립트에서는 일급함수(퍼스트클래스)라는 개념을 도입하여 함수도 해쉬에 넣는다. 하지만 `makeCounter()`를 호출할 때 마다 새로운 함수가 만들어지기 때문에, 공유하고 있는 사물은 프로토타입(prototype)으로 이동하여 관리한다.



### 방법 3. 클로저

```javascript
function makeCounter() {
  var count = 0;
  function push() {
    count++;
    console.log(count);
  }
  return push;
}
c = makeCounter();
c(); // -> 1
c(); // -> 2
c(); // -> 3
```

함수를 함수 안에 정의하고, 내포할 수 있는 정적 스코프가 있어 함수를 반환값으로 사용하거나 변수에 대입하여 사용한다는 개념. 클로저(Closure)라는 이름은 무언가 닫는 느낌이다. 왜 이렇게 불릴까?

- *왜 이것을 클로저라고 부를까? 그것은 자유 변수를 포함한 식을 '열린 식'이라고 부르고, 그 자유 변수의 바인딩을 조합함으로 해당 식을 닫고 있기 때문이다.* - Ake Wikstorm

위 예제로 보자면 함수 `push()`는 변수 `count`를 참조하지만 이것은 함수 `push()` 안에 정의되어 있지 않다. 이런 변수를 자유 변수라 한다. 함수 `push()`는 자유 변수를 포함하고 있기 때문에 열린 함수다. 그리고 함수 `makeCounter()` 대응표에서 0이라는 값과 count라는 이름이 연결되어 있다. 값에 이름을 연결하는 것을 바인딩이라고 한다. 열린 함수 `push()`가 `makeCounter()` 대응표와 세트가 됨으로, 더 이상 그 이외의 스코프에 변수 정의를 찾으러 가지 않아도 되는 완결 상태가 된다. 이것을 '닫았다'라고 표현한다.



### 방법 4. 클래스

자바를 배울 때 클래스를 왜 사용하는지 먼저 배우지 않고, 클래스를 사용해야 한다고만 배운다. 클래스는 '그렇게 쓰는게 편하다'는 이유로 만들어진 규칙에 불과하다.

#### Hoare가 생각한 클래스

1965년 Hoare가 쓴 ALGOL 확장안에서 '현실 세계의 사물(objects)은 편의상 상호 베타적 종류(classes)로 분류될 수 있다. (중략) 어떤 종류의 사물을 더욱 세분화된 종류(subclasses)로 분류할 수 있으면 편리하다'고 주장. 즉, Hoare에게 클래스는 분류의 개념.

#### C++의 클래스

C++ 의 창시자 Bjarne 는 C++의 클래스 개념을 '클래스는 타입(type) 이다.'라고 주장한다. `int`나 `float`등의 기본형 처럼 동이랗게 다룰  수 있는, 새로운 형을 사용자가 정의할 수 있도록 한 것이다. C에서도 여러가지 형 변수를 모아서 새로운 형을 만드는 '구조체'라는 기법이 있었다. 여기에 Bjare가 생각한 여러 가지 기능이 추가된 것이다. 그 중 하나는 **사양**으로서의 역할이다. 즉, 클래스는 '객체가 어떤 메소드를 갖고 있고, 어떤 메소드를 갖고 있지 않은가'라는 사양을 선언하는 역할도 했다. 존재하지 않는 메소드를 호출하면 에러가 발생한다.

#### SmallTalk

스몰토크에서는 메소드 호출은 '이런 이름의 메소드를 실행해줘'라는 메시지를 객체에게 전달하는 것이며, 그 메시지를 받은 객체가 어떤 동작(무언가를 실행할지, 에러 처리를 할지, 무시할지 등)을 할지는 수신 객체가 자유롭게 결정. 스몰토크의 창시자이자 객체지향이라는 용어를 발명한 Alan Kay는 이런 자유가 객체 지향의 중요한 요소라고 생각.

#### 클래스의 역할

- 결합체를 만드는 생성기
- 어떤 조작이 가능한지에 대한 사양
- 코드를 재사용하는 단위

Perl이나 Javascript에서는 (1)의 생성기에 중점. C++은 (2)에 중점. Java에서는 이 역할을 특화시킨 인터페이스 라는 개념을 도입.



## 정리

객체 지향은 현실 세계의 사물 모형을 만들기 위해 처음 등장. 각 언어마다 이 객체 지향이라는 용어를 다른 방식으로 해석하였으며 다른 방식으로 구현.