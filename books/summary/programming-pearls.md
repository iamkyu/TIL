# 생각하는 프로그래밍을 읽고

> [생각하는프로그래밍|저자 존 벤틀리|역자 윤성준, 조상민|인사이트 |2013.12.24](http://book.naver.com/bookdb/book_detail.nhn?bid=7390670) 을 요약.



매 칼럼 마다 등장하는 연습 문제는 생각 보다 수준이 높아 대부분 풀지 못했다. 책의 내용도 생각보다 어려워 여러 번 읽었다. 모든 칼럼들의 내용을 완전히 흡수하려 하기 보다는 큰 맥락에서 흐름을 따르가며 책을 읽었다.

> 프로그래밍 언어 문법을 외우고 개발 도구 사용법을 익히면 소프트웨어를 만들 수 있다고 흔히 생각하지만, 실제 세계에서 부딪히는 개발 작업은 도구의 단순 사용을 반복하는 것이 아니라 깊은 사고력을 요하는 기예에 가깝다. 시시각각 변하는 환경과 제한 된 예산, 기간의 압박 속에서 각자 한계가 있는 현존 기술로 최적의 해법을 찾는 일을 도구나 언어가 100% 대신해 줄 수는 없다.
>
> -존벤틀리 저. 생각하는 프로그래밍. 윤성준, 조상민 역. 인사이트. 2013. 책 뒷 표지 중



# 1부 준비

> 그 프로그래머의 질문은 간단했다. "디스크 파일을 어떻게 정렬하지?" (중략) 내 실수는 그의 질문에 그냥 답하려고 했던 것이었다. 나는 그에게 디스크상에서 머지정렬을 어떻게 구현하는지 간단히 설명해 주었다. 알고리즘 책을 찾아 보라는 내 충고에 그의 반응은 냉담했다.
>
> -존벤틀리 저. 생각하는 프로그래밍. 윤성준, 조상민 역. 인사이트. 2013. 19페이지

이런 에피소드로 책을 시작한다. 나는 프로그래밍을 공부하는 과정에서 자료구조와 알고리즘을 배웠다. 하지만 그런 내용들을 배울 당시, 도대체 이런 것들을 어디 쓸 지 몰랐다. 실제 업무에서 프로그래밍을 하다 보니 데이터 집합을 다룰 필요가 있었고, 어떤 때에는 그 데이터 집합의 구조를 변경하고 특정 데이터를 탐색 할 필요도 있었다. 그 과정에서 알고리즘과 자료구조에 대한 지식의 필요를 느꼈고, 이미 잊어 버린 지식들을 다시 학습하는 시간을 가지기도 했다. 그러나 그렇게 학습한 지식 중 일부만을 실제 업무에서 잦은 빈도로 자주 사용하였다. 말 그대로 "사용"하였다. 내가 직접 알고리즘이나 자료구조를 구현할 필요 없이 언어 레벨에서 제공해주는 라이브러리를 사용하면 별로 많은 고민이 필요하지 않았다. 단지 어떤 것이 좀 더 효율적일지 잠깐 고민하고 선택하면 그만이었다.

위 에피소드로 돌아가서 얘기하자면, 해결하고자 하는 문제 영역의 몇 가지 기술적 이슈가 있었고 이로 인해 일반적인 정렬을 사용 할 수 없는 상황이었다. 그래서 이 문제 영역에 최적화 된 해결책을 구현해야 하는 상황이었던 것이다.

> 이 책에서는 문제를 해결하는 데 있어 처음에는 단순하게 생각할 수 있는 방법으로 접근하고 그 방법이 왜 문제인지를 설명한 다음 보다 효율적으로 문제를 해결할 수 있는 다른 방법을 제시한다.
>
> -존벤틀리 저. 생각하는 프로그래밍. 윤성준, 조상민 역. 인사이트. 2013. 역자 서문 중

이 칼럼을 읽으면서 그동안 간과하고 있던 것이 떠올랐다. 언어 레벨에서 제공하는 자료의 구조나 정렬 방법이 보편적으로 많이 알려지고 어느정도 검증 된 것들이긴 **내 문제**에 최적화 된 해결책들은 아니다. 물론 어설프게 내가 직접 구현한 것 보다는 훨씬 수준 높은 해결책들이겠지만 말이다. 내가 어떤 문제를 해결하려고 할 때 보기(라이브러리)로 주어진 알고리즘과 자료구조를 선택할 것인가로 고민이 끝나는게 아니라, 과연 이 것이 내 문제에 대한 최고의 해결책인지에 대해서 고민이 필요하다고 생각했다.

책의 1부에서는 문제를 마주하고 그 문제를 해결하는 프로그램을 작성하는 과정의 흐름을 기술한다.

## 정확한 문제 기술 (칼럼1)

> 문제를 정의하는 것은 그 문제를 해결하는 데 있어 큰 몫을 차지한다.
>
> -존벤틀리 저. 생각하는 프로그래밍. 윤성준, 조상민 역. 인사이트. 2013. 26페이지

요구 사항을 정확하게 분석하고 문제의 명세(Specification)에 대해서 깊이 고민한다. 작은 문제에 대해서도 주의 깊게 분석하면 때로는 엄청난 실질적 이익을 얻을 수 있다. 정확한 분석이 모든 것의 시작이다.

## 알고리즘 디자인 (칼럼2)

> 어려워 보이는 문제이지만 간단하면서도 기대하지 않았던 솔루션이 있는 경우가 있다. (Martin Gradner 저. Aha! Insight)
>
> -존벤틀리 저. 생각하는 프로그래밍. 윤성준, 조상민 역. 인사이트. 2013. 33페이지

잘 알려진 정렬이나 탐색 알고리즘을 단순히 사용하는 것이 아니라 내가 해결하고자 하는 문제에 알맞게 디자인 하여 프로그램의 성능을 높일 수 있다. 책에서 든 몇 가지 예제 중 인상 깊었던 것은, 40억 개의 32비트 정수가 랜덤한 순서로 들어 있는 순차적 파일에서 누락 된 하나의 정수를 찾아야 한다. 이 문제에 습관적으로 이진 탐색이 가장 빠르지 않을까 하고 생각했다. 하지만 이진 탐색을 적용하기 전에 이분법(bisection method)으로 절반으로 나눈 후, 하나가 적은 쪽이 정수가 누락 된 범위라는 것을 알 수 있다. 그 후, 그 절반만을 대상으로 탐색함으로써 전체를 탐색하는 것 보다는 훨씬 빠른 결과를 얻을 수 있었다. 이미 잘 알려진 정렬 알고리즘을 그대로 사용하는 것이 아니라 내 문제에 맞춰 디자인 하는 것이다.

## 데이터 구조의 선택 (칼럼3)

데이터 구조를 잘 설계하면 큰 프로그램을 작게 만들 수 있다. 잘 설계된 데이터 구조는 실행시간과 메모리 사용량을 감소 시키고, 포팅과 유지보수를 쉽게 하는 등 여러 가지 긍정적인 효과를 가진다(67P). 반복되는 코드는 배열을 사용하여 다시 작업해보고 복잡한 구조는 캡슐화 한다.

## 코드 구현과 테스트 (칼럼4 - 칼럼5)

> 프로그래밍이라는 것에 대해 정확히 파악해 볼 필요가 있다. 코딩 기술은 정확한 프로그램을 작성하는 데 있어 작은 한 부분에 지나지 않는다. 작업의 대부분은 앞의 세 칼럼에서 다루었던 문제 정의, 알고리즘 디자인, 데이터 구조의 선택이다. 이 작업들을 잘해낼 수 있다면, 정확한 코드의 구현은 쉬운 것이 보통이다.
>
> -존벤틀리 저. 생각하는 프로그래밍. 윤성준, 조상민 역. 인사이트. 2013. 73페이지

문제정의, 알고리즘 디자인, 데이터 구조를 잘 선택했다면 코드의 구현은 쉽다고 말하며 4번째 칼럼을 시작한다. 하지만 막상 내용을 보면 실제로 코드를 작성하느 일은 미묘한 어려움이 있고 신중함이 필요한 일이라고 이야기한다. 그래서 코드를 꼼꼼하게 검증하고 이 코드를 시스템에 적용하기 전에 스케폴딩(scaffolding)을 만들어 증명한다. 그리고 테스트를 작성하고 자동화한다. 

> 골치 아픈 버그를 해결하는 데 결정적 힌트가 되는 것은 적절한 질문이었다.
>
> -존벤틀리 저. 생각하는 프로그래밍. 윤성준, 조상민 역. 인사이트. 2013. 113페이지



# 2부 퍼포먼스

> 모든 것은 가능한 단순해져야 하지만, 그 이상 단순해지면 안 된다.
>
> -존벤틀리 저. 생각하는 프로그래밍. 윤성준, 조상민 역. 인사이트. 2013. 143페이지

2부의 시작은 "봉투 뒷면에 하는 간단한 계산"이라는 칼럼으로 시작한다. 복잡한 문제를 풀기 전, 봉투 뒷면에 계산할 정도로 단순화 하고 추정하는 것이다. 본격적으로 문제를 해결하기 전에 이렇게 문제를 추정하는 것은 때때로 문제를 더 쉽게 해결할 수 있는 실마리를 제공하기도 한다. 따라서 일상 속에서도 "워싱턴 DC까지 걸어가는데 얼마나 오래 걸릴까?", "올해 얼마나 많은 나뭇잎을 갈퀴로 긁어 모을 수 있을까?" 같은 질문들에 추정하고 계산하는 습관을 기르는 것이 좋겠다.

> 예나 지금이나 프로그램을 간결하게 만들기 위해 열심히 생각하는 것은 득이 될 수 있다.
>
> -존벤틀리 저. 생각하는 프로그래밍. 윤성준, 조상민 역. 인사이트. 2013. 191페이지

2부에서는 문제정의, 시스템구조, 알고리즘 디자인과 데이터 구조 선택과 같은 고수준(High-level)의 접근 방법과 코드 튜닝과 같은 저수준(Low-Level)의 퍼포먼스 향상 기법과 사례들을 얘기한다. 나는 이제까지 비교적 소규모 웹애플리케이션을 개발하면서 성능 최적화에 대해 진지하게 고민해 본적은 없다. 그보다는 보다 사람이 읽기 좋은 코드를 작성하는데 많이 집중하였다. 하지만 애플리케이션의 퍼포먼스는 본질적으로 중요한 요소이기 때문에 이에 대해서도 간과해서는 안되겠다고 느꼈다.



# 3부 프로덕트

다시 읽기!