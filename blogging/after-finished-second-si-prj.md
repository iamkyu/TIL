두번째 SI 프로젝트를 마무리 하며
===

두번째 시스템 구축 (System Integration) 프로젝트가 거의 마무리 되었다. 사실 첫 번째 SI 프로젝트는 중간에 투입 되었고 유지보수나 프로토타입 개발을 제외하면 처음부터 끝까지 온전히 참여한 프로젝트는 이번이 처음이다. 프로젝트 성격은 경영자정보 시스템(Executive Information System) 구축으로, 각종 데이터를 취합한 후 통계를 구해 차트와 표로 보여 주는 웹 어플리케이션이다. 그래서 `코드(Code)` 보다 `데이터(Date)`가 중심이 되는 프로젝트였다.

사용 된 기술 스택은 아래와 같이 나온지 오래되었고 시장에서 검증 된 보편적인 기술들이 사용되었다.

- JDK 6 (Spring Framework)
- DBMS: IBM DB2 (iBatis Framework)
- HTML, CSS, Javscript/jQuery
- 서버 환경: UNIX AIX, Tomcat7


> 젊은 시절 나의 가장 큰 불만은 이런 것이었다. 엄청난 흥미를 가지고 새 프로젝트를 시작해서는 시간이 지남에 따라 서서히 코드가 썩어가는 걸 보게 된다. 일년쯤 지나면 하루라도 빨리 냄새 나는 코드를 던져 버리고 다음 프로젝트가 시작되기만을 기다리는 것이다.

-켄트벡 저. 테스트주도개발. 김창준, 강규영 역. 인사이트. 2005. 320페이지

실제로 프로젝트 중반부터는 매일 위와 같은 생각을 했는데, 내가 작성한 코드를 보며 내가 저런 생각을 한다는건 정말 어처구니 없는 일이다. 짧다면 짧고 길다면 긴 기간 동안 진행 한 이번 프로젝트를 하며 느낀 점을 정리 해 본다. 같은 실수를 반복하지 않길 바라며.


## 개발 프로세스

각각의 화면에는 검색 조건들이 있다. 조건을 설정 후 검색버튼을 누르면 화면은 가만히 있지만 데이터들이 변한다. 이런 이론을 바탕으로 `Ajax` 기술을 활용하여 전체 페이지를 리로딩 할 필요 없이 필요한 경우에만 비동기로 데이터만을 새로 가져 온다. 그 데이터를 가져 오기 위한 각각의 리소스는 고유의 `URI`를 가지고 있게 되고, 나는 이게 `RESTful`한 방식의 개발인 줄 알았다. 그런데 이건 내가 잘못 이해 하고 있었던 듯 하고, 관련 글들을 찾아봤지만 사실 `RESTful` 의 명확한 정의는 잘 모르겠다. 아래의 글들이 도움이 될 듯 하다.

- [REST 연재-1회 REST 아키텍쳐의 기본](http://bcho.tistory.com/321)

- [도대체 뭐가 RESTful 이라는건가?](http://www.chidoo.me/index.php/2016/06/03/what-is-restful/)

어쨋든 이런 `REST` 비슷한 방식으로 개발을 하게 될 때 가장 장점은, 서버단과 클라이언트단을 분리해서 개발 할 수 있다는 점이다. 특정 `URI`로 요청이 올 때 어떤 파라미터들이 포함되어 올 것이고, 어떤 데이터를 돌려줘야 하는지만 알고 있다면 서버단의 `API(Application Programming Interface)`를 개발하는 과정에서는 웹브라우저를 단 한 번 켤 필요도 없다. 대표적인 Rest Client 툴에는 [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop) 등이 있지만, 내가 사용하는 `IntelliJ`의 경우 IDE 자체에서 이 기능을 제공하기 때문에 IDE를 떠나지 않고 집중력 있게 개발이 가능하다.

첫번째 프로젝트에서는 이런 방식이 처음이라 한 메뉴를 개발할 때 화면부터 서버단까지 쭉 개발하고 다음 메뉴를 개발하는  방식으로 진행 했는데, 전체적인 API를 먼저 정의해 놓은 후에 클라이언트쪽 개발을 하는 것이 효율성이나 집중력 등 다방면에서 훨씬 더 좋았다.

## 자바의 컬렉션 프레임웍(Collection Framework)과 자료구조

이번 프로젝트의 데이터베이스는 굉장히 오래전에 구축 되었고 잘못 설계되어 있는 부분도 있었지만, 어찌됐든 수년간 누적되어 있는 데이터의 양이 상당했기 때문에 거기에 맞춰 개발할 수 밖에 없었다. 이 프로젝트는 `데이터` 중심의 프로젝트 였기 때문에 `SQL`이 핵심이었는데, `DBA`가 따로 있었기 때문에 나는 사실상 데이터를 클라이언트단에 잘 전달해서 화면에 적절히 배치해주기만 하면 되었다. 문제는 새롭게 구축하는 시스템의 화면정의와 같은 구조로 데이터를 가져올 수 없는 경우가 많았는데, 이 경우에 자바에서 이를 가공해줘야 했다. 행(row)과 열(column)을 바꿔야 하는 경우도 있었고, 여러 행들을 합쳐서 완전히 새로운 형식으로 구조를 바꿔야 하는 경우도 있었다. 이 때 자바에서 제공하는 컬렉션프레임웍이 상당히 고마웠다. `List`, `HashSet`, `HashMap` 등을 다양하게 사용한 것 같다. 특히 `Set`은 자료의 순서가 없고 중복도 없는 자료 구조인데, 특정 데이터리스트에서 중복을 걸러내는 과정에서 사용할 수 있었다.

```java
// JDK6 에서는 제네릭의 생성자 영역에도 타입을 명시해야 한다.
HashSet<String> categorySet = new HashSet<String>();
String categoryCodeStr = "";

for (Map<String, String> rowData : categoryList) {
    categoryCodeStr = rowData.get("CODE");

    // 중복 코드를 걸러낸다.
    categorySet.add(categoryCodeStr);
}
List<String> categoryCodeList = new ArrayList<String>(categorySet);
```

위와 같은 식으로 `List` 순회하며 값들을 `HashSet`에 계속 넣어주면 중복 값들은 알아서 저장되지 않고, 그 `Set`을 그대로 `List`의 생성자 매개변수로 전달하여 순서가 있는 데이터 구조로 만들 수 있다. 이런 비즈니스 로직들을 개발하면서 새삼 자료구조 학습의 중요성을 느끼게 되었다.

## 자동화

보통 빌드나 배포는 선임개발자들이 담당하지만, 이번 프로젝트에서의 시범 배포 때에는 다른 프로젝트와의 일정 문제로 선임개발자가 부재중이었기에 내가 직접 배포를 담당해야 했다. 서버 환경은 `UNIX` 였고 나는 해당 OS에 익숙하지 않을뿐만 아니라 터미널 명령어에도 익숙하지 않았기 때문에 많은 학습이 동반되었다. 또한, 시범 배포 후에 계속해서 수정사항이 있었고 바로바로 시범서버에 적용을 원했기 때문에 하루에 3~4번씩 계속해서 재배포를 했다. 순서는 보통 아래와 같이 진행된다.

> 개발 - 빌드 - FTP로 `WAR` 전송 - 톰캣중지 - WEBAPP 교체 - 톰캣가동

이 과정에서 내가 느낀 것은

1. 너무 번거롭다. 또한 서버가 한개도 아니고 개발서버와 운영서버가 있는데 시범 운영 기간에는 이 두 서버에 각각 반복되는 과정을 거치니 굉장히 시간 아깝다는 생각을 했다.

2. 배포 이력 관리가 안된다. 언제 배포 된 웹앱이고 해당 릴리즈의 주요 변경 사항이 어떤 점들인지 알 수 없으며, 만약 급한 상황이 발생하여 `Exploded` 방식으로 배포되고 있는 웹앱의 특정 리소스나 jsp파일만 교체하고 `VCS` 상에서는 버전 관리가 안되었다면 추후 큰 문제를 초래 할 수 있다.

이런 문제를 해결하고 자동화를 위해 Jenkins와 같은 CI(Continuous Integration, 지속적 통합) 툴을 학습하고 도입할 필요를 느꼈다. 개인 서버에 해당 환경을 갖추어 테스트 하고 나중에 진행 되는 프로젝트에서는 꼭 CI를 적용할 수 있도록 해야겠다.

## 소프트웨어 품질

내가 가장 놀란 것은 모든 사람들이 지나칠 정도로 소프트웨어 품질에 관심이 없다는 것이다. 심지어 비용을 지불하는 클라이언트 까지도. 단위테스트나 `Selenium` 같은 브라우저에서의 테스트 도구, 코드 리뷰를 통해 내 코드들이 어느 정도 검증이 되고 수치적으로 테스트 커버리지가 얼마나 되는지가 명확하게 나온다면 좀 더 마음이 놓일 것이다. 하지만 그런 문화의 부재로 내가 짜긴 했지만 내 코드에 대한 불신을 감출 수 없다. 내가 적극적으로 나서 문화를 바꾸기엔 아직 역량이 부족하다. `Spring Boot`, `ORM(Object-relational mapping)`에 관심이 있어 최근 시작한 프로젝트형 스터디의 진행 방식은 테스트 커버리지는 75% 이상 되어야 하며, 개발 완료한 부분은 `Pull Request`를 보내 팀원들이 리뷰 후 Okay가 되어야지 소스가 반영되는 식으로 진행 된다. 실력자분들과 함께 하는 스터디라 이 스터디를 진행하며 그런 TDD 방식의 개발 프로세스를 차근 차근 익혀야겠다.

## 마음가짐

> Clean code that works

굉장히 유명한 말이고, 내가 추구하는 것이기도 하다. 그런데 이번 프로젝트에서 내가 짜 놓은 코드들을 보면 한숨 밖에 안나온다. `MVC` 구조에서 Model, View, Controller 의 책임은 명확하게 나뉘는 것이 좋다. view는 화면을 보여주는데만 집중하고, Model 은 비즈니스 로직을 처리하는데만 집중한다. 그런데 가끔은 자바 보다는 뷰(view)단의 자바스크립트로 어떤 로직들을 처리할 때가 편할 때가 있다. 이런 유혹을 이기지 못하고 타협해 버리면 뷰는 `HTML`, `CSS`, `JavaScript` 의 소스가 모두 섞여 있기 때문에 소스의 양이 조금만 늘어도 읽기가 힘들어지고 스파게티 소스가 된다. 결국 중요한 것은, 타협하지 않는 마음가짐인 것 같다. 잠시 귀찮음을 이겨 내지 못하고 타협해버린 한 줄 또는 한 모듈의 코드들이 소프트웨어의 품질을 떨어뜨린다. 적어도 코드(Code) 레벨에서는 타협하지 말자.